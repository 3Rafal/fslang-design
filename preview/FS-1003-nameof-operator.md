
# F# RFC FS-1003 - nameof Operator

The design suggestion [nameof operator](https://github.com/fsharp/fslang-suggestions/issues/252) has been marked "approved in principle".
This RFC covers the detailed proposal for this suggestion.

[Discussion thread](https://github.com/fsharp/FSharpLangDesign/issues/48)

* [x] Approved in principle
* [x] Details: [Resolved to Preview](https://github.com/fsharp/FSharpLangDesign/issues/48)
* [x] Implementation: [Complete to Preview](https://github.com/Microsoft/visualfsharp/pull/6325)

### Introduction

It's often useful to obtain the simple (unqualified) string name of a variable, type, or member. Today users end up writing something like this:

```fsharp
let add x y =
    if x < 0 then raise (ArgumentOutOfRangeException("x"))
    x + y
```

This RFC allows user code to extract the name of a declaration, like:

```fsharp
let add x y =
    if x < 0 then raise (ArgumentOutOfRangeException(nameof(x))
    x + y
```

### Design Principles

The design principles for F# `nameof` are as follows.

1. For `nameof(text)` to resolve to a symbol, then `text` must resolve to the same symbol if used in a normal way at that point in the source code.  

2. To whatever extent possible, `nameof(M)` must be robust under rename-refactor of symbol `M` in typical F# tooling. That necessitates `M` carrying enough information to give a precise symbol resolution down to a specific member, value, function, namespace etc. 

3. Where possible, as little new logic must be added to the design of F#. It is better from both cognitive (ease-of-learning) and implementation perspectives to minimise the new logic and rules.

4. The feature should be simple and easy to use.

5. The feature should align with other F# language features.

6. The feature should otherwise be similar to the corresponding C# feature.

NOTE: These design principles vary from C#.  For example:

1. `nameof(M)` in C# can resolve to an instance member.  F# doesn't support unqualified resolution of instance members, so a dummy `this` argument is needed, e.g. `nameof(Unchecked.defaultof<C>.M)` or `nameof(this.M)` etc.

2. `nameof(M)` in C# doesn't need annotation for an overloaded member. This results in ambiguity when `M` is renamed.  In F# additional information must be added to identify the precise member, so that if renaming occurs the symbol is accurately renamed.  



### Detailed Processing Rules for `nameof expr`

A library function `FSharp.Core.Operators.nameof` is added.  When used we adjust the processing of the expression form
```fsharp
    nameof expr
```
Here `expr` is syntactically an expression and is processed as follows:
1. If `expr` is of the form `(expr2)` then the parentheses are ignored and `expr` is processed

2. If `expr` is of the form `expr2 : type` then `type` is processed and `expr2` is processed using the resulting known type

3. If `expr` is a long  identifier e.g. `id1.id2.id3` then it is resolved as either

   a. a namespace or module
   
   b. a type name
   
   c. is checked as a long identifier expression (using any available known type from a type annotation)


### Naming 

The name of the operator is `nameof`. It is an intrinsic in FSharp.Core

### Scope of use

- can be used with method parameters

- can be used with local variables

- can be used with local (nested) functions

- can be used with local curried functions

- can be used with local tupled functions

- can be used with provided symbol names, i.e. generated by type providers

- can be used from inside a local function (needs to be let rec)

- can be used with member names

- can be used with static member names

- can be used with static property names

- can be used with names that are quoted in <code>``</code>

- can be used with names of operators like `+`, `|>`, `typeof`, `nameof`, evaluating to the compiled name of the operator

- can be used with generic functions/types

- can be used in attributes

- can be used with namespaces, `nameof(System.Diagnostics)`

- can be used with type names, `nameof(System.String)`

- can be used with module names, `nameof(FSharp.Collections.List)`

Other considerations:

- the use of `nameof` is allowed in quotations, the substitution is still made at compile-time

- the text `nameof` may resolve to something user-defined (this avoids a breaking change)

- `nameof` may not used like a first-class function value, `let f = nameof ;; f x`

- `nameof` may not be used with pipe operator, `x |> nameof`

- `nameof` does not perform "forward lookup", such as taking the name of a parameter to a method or function in an argument that decorates it

### Names of instance members

Names of members must be static or come from an instance. So the following code that attempts to get the name of an instance property with an instance of its containing class is not valid:

```fsharp
type C() =
    member _.M = ()

nameof C.M // Error!
```

But the following are valid::

```fsharp
type C() =
    static member M = ()
    member _.M2 = ()

nameof C.M // Yay :)

let c = C()
nameof c.M2 // Yay :)

nameof Unchecked.defaultof<C>.M2 // Yay :)
```

### Names of overloaded members require a type annotation

When selecting an overloaded member, a type annotation may be necessary to select a precise member:
```fsharp

type MethodGroupNameOfTests() =
    member this.MethodGroup() = ()    
    member this.MethodGroup(i:int) = ()

    member this.MethodGroup1(i:int, f:float, s:string) = 0
    member this.MethodGroup1(f:float, l:int64) = "foo"
    member this.MethodGroup1(u:unit -> unit -> int, h: unit) : unit = ()

    member this.``single argument method group name lookup`` () =
        let b = nameof(this.MethodGroup)
        Assert.AreEqual("MethodGroup",b)

    member this.``multiple argument method group name lookup`` () =
        let b = nameof(this.MethodGroup1 : (float * int64 -> _))
        Assert.AreEqual("MethodGroup1",b)
```
See note above for the design rationale, i.e. precise symbol renaming.

### Names of operators reveal the compiled name of the operator

In general `nameof` does *not* reveal the compiled name of a symbol.  For example
```fsharp
nameof(List.map)   // gives "map" not "Map" (the CompiledName)
nameof(List<int>)   // gives "List"
nameof(list<int>)   // gives "list" even though List<T> = list<T> is a type abbreviation
nameof(System.DateTime.Now)   // gives "Now" 
nameof(System.DateTime.get_Now)   // gives "get_Now" 
```
However, for operators the compiled name is revealed.  For example:
```fsharp
nameof(+)   // gives "op_Addition"
nameof(op_Addition)   // gives "op_Addition"
```

### Names of generic type instantiations are permitted

The `nameof` construct can be used with generic type instantiations, e.g.

```fsharp
type C2<'T> = A | B
type C3<'T>() = class end

nameof(C2)      // gives "C2"
nameof(C2<int>) // gives "C2"
nameof(C2<_>)   // gives "C2"
nameof(C3)      // gives "C3"
nameof(C3<_>)   // gives "C3"
```

### `nameof` on generic type parameters is not permitted

In the preview release, the `nameof` construct can't be used with type arguments, `let f<'t> (x : 't) = nameof 't`.  This is because syntactically the argument to `nameof` is an expression, and not a type.

NOTE: this was by design for the preview, but is being reconsidered, see unresolved issues below.

### `nameof` of a function using `RequiresExplicitTypeArguments` may require explicit type parameters

F# functions labeled with the `RequiresExplicitTypeArguments` require the use of a dummy type instantiation:

```fsharp
nameof(typeof<_>)
```

NOTE: this attribute is used very rarely.  

### Literals

It is permitted to use `nameof` in a literal, e.g.., `let rec [<Literal>] Foo = nameof Foo`

### Performance considerations

This substitution should be done at compile time, no performance impact expected

## Alternatives

See also unresolved issues below.

### Alternative: formalize the notion of a named entity

In the [C# version of this feature](https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#nameof-expressions), the `nameof` expression takes a `named_entity` as input. A named entity is a valid expression, with one key
distinction: instance members that fail to resolve due to being in a static context **do not** fail to
resolve when in the context of a `nameof` expression. It is also an error for a named entity designating
a method group to have type arguments.

For F#, we have instead adopted the principle that, like in F# quotations, enough information should be given to specify a
precise symbol resolution, rather than adding this new concept to the language definition just for this one feature.

Further, F# doesn't support unqualified resolution of instance members, and it would be unnatural and complexifying to add that
capability here.

#### Alternative: use a keyword not a library intrinsic

This would have been a breaking change.

## Unresolved issues (based on preview)

None

