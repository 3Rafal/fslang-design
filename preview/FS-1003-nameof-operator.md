
# F# RFC FS-1003 - nameof Operator

The design suggestion [nameof operator](https://github.com/fsharp/fslang-suggestions/issues/252) has been marked "approved in principle".
This RFC covers the detailed proposal for this suggestion.

[Discussion thread](https://github.com/fsharp/FSharpLangDesign/issues/48)

* [x] Approved in principle
* [x] Details: [Resolved to Preview](https://github.com/fsharp/FSharpLangDesign/issues/48)
* [x] Implementation: [Complete to Preview](https://github.com/Microsoft/visualfsharp/pull/6325)

### Introduction

It's often useful to obtain the simple (unqualified) string name of a variable, type, or member.

Today users end up writing something like this:

```fsharp
let add x y =
    if x < 0 then raise (ArgumentOutOfRangeException("x"))
    x + y
```

It would be useful to have this to extract the name of expressions, like:

```fsharp
let add x y =
    if x < 0 then raise (ArgumentOutOfRangeException(nameof(x))
    x + y
```

### Naming 

The name of the operator is `nameof`

### Scope of use

- allowed in quotations
- allowed with provided symbol names, i.e. generated by type providers
- allowed with method parameters
- allowed with local variables
- allowed with local (nested) functions
- allowed with local curried functions
- allowed with local tupled functions
- can get name from inside a local function (needs to be let rec)
- can get member names
- can get static member names
- can get static property names
- can get names that quoted in <code>``</code>
- can get names of operators like `+`, `|>`, `typeof`, `nameof`, ...
- can be used in pattern matching
- can be used with generic functions/types
- works in attributes
- works with namespaces, `nameof System.Diagnostics`
- works with types, `nameof System.String`
- works with modules, `nameof List`
- works with type arguments, `let f<'t> (x : 't) = nameof 't`

Other considerations:

- `nameof` may already resolves to something user-defined, avoids a breaking change
- not allowed when used like a function, `let f = nameof ;; f x`
- not allowed when used with pipe operator, `x |> nameof`

### Names of members 

Names of members must be static or come from an instance.

So the following code that attempts to get the name of an instance property with an instance of its containing class is not valid:

```fsharp
type C() =
    member __.M = ()
    
nameof C.M // Error!
```

But the following are valid::

```fsharp
type C() =
    static member M = ()
    member __.M2 = ()
    
nameof C.M // Yay :)

let c = C()
nameof c.M2 // Yay :)
```

### Overloaded members

When selecting an overloaded member, a type annotation may be necessary to select a member:
```fsharp

type MethodGroupNameOfTests() =
    member this.MethodGroup() = ()    
    member this.MethodGroup(i:int) = ()

    member this.MethodGroup1(i:int, f:float, s:string) = 0
    member this.MethodGroup1(f:float, l:int64) = "foo"
    member this.MethodGroup1(u:unit -> unit -> int, h: unit) : unit = ()

    member this.``single argument method group name lookup`` () =
        let b = nameof(this.MethodGroup)
        Assert.AreEqual("MethodGroup",b)

    member this.``multiple argument method group name lookup`` () =
        let b = nameof(this.MethodGroup1 : (float * int64 -> _))
        Assert.AreEqual("MethodGroup1",b)
```

### Performance considerations

This substitution should be done at compile time, no performance impact expected

## Alternatives

TBD

## Unresolved issues (for release from preview)

* [ ] Resolving instance members requires an artificial instance object.

* [ ] No way to get the name of a generic type parameter.

* [ ] Resolving overloaded members requires a type instantiation.



